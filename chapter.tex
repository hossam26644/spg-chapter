%%%%%%%%%%%%%%%%%%%% author.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample root file for your "contribution" to a contributed volume
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%% Springer %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% RECOMMENDED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[graybox]{svmult}

% choose options for [] as required from the list
% in the Reference Guide

\usepackage{mathptmx}       % selects Times Roman as basic font
\usepackage{helvet}         % selects Helvetica as sans-serif font
\usepackage{courier}        % selects Courier as typewriter font
\usepackage{type1cm}        % activate if the above 3 fonts are
                            % not available on your system
%
\usepackage{makeidx}         % allows index generation
\usepackage{graphicx}        % standard LaTeX graphics tool
                             % when including figure files
\usepackage{multicol}        % used for the two-column index
\usepackage[bottom]{footmisc}% places footnotes at page bottom

% see the list of further useful packages
% in the Reference Guide

\makeindex             % used for the subject index
                       % please use the style svind.ist with
                       % your makeindex program

%%%%%%%%%%%%%%%%%%%%
% Extra packages
%%%%%%%%%%%%%%%%%%%%
\usepackage{minted}
\usepackage{natbib}
\bibliographystyle{plainnat}

\newminted{python}{fontsize=\footnotesize}

%%%%%%%%%%%%%%%%%%%%
% local macros
%%%%%%%%%%%%%%%%%%%%

\newcommand{\msprime}[0]{\texttt{msprime}}
\newcommand{\ms}[0]{\texttt{ms}}
\newcommand{\apiref}[1]{\texttt{#1}}

\newcommand{\includenbimage}[1]{\begin{center}\includegraphics{#1}\end{center}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title*{Coalescent simulation with msprime}
% Use \titlerunning{Short Title} for an abbreviated version of
% your contribution title if the original one is too long
\author{Jerome Kelleher and Konrad Lohse}
% Use \authorrunning{Short Title} for an abbreviated version of
% your contribution title if the original one is too long
\institute{Jerome Kelleher \at
Big Data Institute, Li Ka Shing Centre for Health Information and Discovery,
University of Oxford, Oxford, OX3 7FZ, UK. \email{jerome.kelleher@bdi.ox.ac.uk}
\and Konrad Lohse \at Institute of Evolutionary Biology, University of Edinburgh,
King's Buildings, Edinburgh EH9 3FL, UK. \email{konrad.lohse@ed.ac.uk}}
%
% Use the package "url.sty" to avoid
% problems with special characters
% used in your e-mail or web address
%
\maketitle



\abstract{Coalescent simulation is really useful. It's easy to simulate stuff with msprime. Examples of stuff that you can simulate.}


\section{Introduction}
\label{sec:introduction}

This chapter is a tutorial for running and analysing coalescent simulations
using \msprime~\citep{kelleher2016efficient}.

% Other simulators you might use.
The \msprime\ simulator is based on the classical \ms\
program~\citep{hudson2002generating} and the models for population
structure and demography are directly derived from the approach taken
in \ms. [Quick round up of other simulators]


Thanks to the rapid advances in sequencing technologies generating
genome-wide sequence datasets for any species has become routine and
there is great interest in learning about the demographic and selective
past of populations from sequence variation. The coalescent gives an
elegant mathematical description of the ancestry of a sample of
sequences from a more or less idealized population and, given its focus
on samples, has become the bread and butter of modern population
genetics.

However, despite the flood of sequence data and the plethora of
coalescent-based inference tools now available, many analyses of genome
wide variation remain superficial or entirely descriptive. Developing
efficient inference methods has been difficult for two reasons. First,
analytic results for models of population structure and/or history are
often restricted to average coalescence times and small (often pairwise)
samples. Even when it is possible to derive the full distribution of
genealogies for realistic samples sizes and models, the results are
cumbersome and generally rely on automation (Lohse 2016). Second, and
perhaps more fundamentally, dealing with recombination has proven
extremely challenging and we still lack a full analytic description of
genetic drift and recombination even under the simplest null models (in
the absence of demography and selection). Thus, inference methods that
incorporate linkage information generally rely on drastic simplifying
assumptions about recombination (cite SMC papers and Song).

Given the severe limitations of relating sequence variation to
mechanistic models analytically, coalescent simulations have become an
integral part of inference in a number of ways: First, comparisons
between analytic results against simulations serve as an important
sanity check for both. Second, while it is often possible to use
analytic approaches to obtain unbiased point estimates of demographic
parameters by ignoring linkage (cite dadi and ), quantifying the
uncertainty and potential biases in such estimates requires simulating
data with linkage to conduct parametric bootstrapping. Finally, a range
of inference approaches that rely on coalescent simulations directly to
approximate the likelihood or - in a Bayesian setting - the posterior,
of parameters under arbitrarily complex models of demography:
Approximate Bayesian computation (ABC) (cite DIYABC, msBayes) has
evolved ii) Approximate likelihood methods either based on SNPs (cite
Excoffier) or blockwise data (cite ABLE).

From the perspective of the user, inference tools are generally
implemented with a command line or graphical user interface and are
designed for a more or less narrow set of inference problems. Moreover,
curent inference methods are based on a variety of coalescent simulators
which are often. The aim of this chapter is to illustrate that how
msprime (and its API) provides a flexible way to run and use coalescent
simulations under under any model. We first explain the basic
datastruture and methods msprimes for coalescent simulations and then
show by the way of a set of simple practical examples how msprime can be
used to obtain predictions for commonly used data summaries and
diffferent models of demography. Finally, we show how msprime can be
used to set up a ABC inference.



\section{Running simulations}
\label{sec:simulations}


\subsection{Trees and replication}\label{running-simulations}
    At the simplest level, coalescent simulation is about generating trees.
These trees represent the simulated history of a sample of individuals
drawn from an idealised population (in later sections we show how to
vary the properites of this idealised population). The function
\texttt{msprime.simulate} runs these simulations, and the parameters
that we provide to this function determine the exact simulation that we
run. It returns a \texttt{TreeSequence} object, which represents the
full simulated history of the sample. In later sections we discuss the
effects of recombination, when this \texttt{TreeSequence} contains a
list of correlated trees. For now, we assume that there is no
recombinations, and we use the method \texttt{first()} to obtain the
tree object from this tree sequence. For example, here we simulate a
history for a sample of three chromosomes:

\begin{pythoncode}
ts = msprime.simulate(3)
tree = ts.first()
SVG(tree.draw())
\end{pythoncode}
\includenbimage{images/simulations_5_0.pdf}

    In this tree we have 5 nodes. Nodes 0, 1 and 2 are \emph{leaves}, and
represent our samples. Node 3 is an \emph{internal} node, and is the
parent of 0 and 1. Node 4 is also an internal node, and is the root of
the tree. In mpsrime, we always refer to nodes by their integer IDs and
obtain information about these nodes by calling methods on the tree
object. For example the code \texttt{tree.children(4)} will return the
tuple \texttt{(2,\ 3)} here, as these are the node IDs of the children
of the root node. Similarly, \texttt{tree.parent(0)} will return
\texttt{3}.

The height of nodes in a tree are determined by their \emph{time}; this
is how long ago the ancestor that corresponds the node was born. So,
contemporary samples always have a node time of zero, and time values
increase as we go upwards in the tree (and further back in time). Times
in msprime are always measured in \emph{generations}.

When we run a single simulation, the resulting tree is a single random
sample from the probability distribution of coalescent trees. Since a
single random draw from any distribution is not usually informative, we
nearly always need to run many different \emph{replicate} simulations to
obtain useful information. This simplest way to do this in msprime is to
use the \texttt{num\_replicates} argument.

\begin{pythoncode}
N = 1000
mean_T_mrca = 0
for ts in msprime.simulate(10, num_replicates=N):
    tree = ts.first()
    mean_T_mrca += tree.time(tree.root)
mean_T_mrca = mean_T_mrca / N
print(mean_T_mrca)

>>> 3.6717548653768133
\end{pythoncode}

    In this example we run 1000 independent replicates of the coalescent for
a sample of 10 chromosomes, and compute the mean time to the most recent
common ancestor of the entire sample, or equivalently the root of the
tree. (The value we obtain is a highly unrealistic 3.5 generations in
the past; however, this is unsurprising since we have specified a highly
unrealistic population model. See the next for more details on how to
specify population models and interpret simulation times.) The
\texttt{simulate} function behaves slightly differently when it is
called with the \texttt{num\_replicates} argument: rather than returning
a single tree sequence we return an \emph{iterator} over the individual
replicates. What this essentially means is that we can use the
convenient \textbf{for} loop construction to consider each simulation in
turn, but without actually storing all these simulations. As a result,
we can run millions of replicates using this method if needs be without
using any extra storage.

When simulating coalescent trees, we are often interested in more than
just the mean of the distribution of some statistic. Rather than compute
the various summaries by hand (as we have done for the mean in the last
example), it is much more convenient to store the result for each
replicate and analyse this array after the simulations have completed.
For example:

\begin{pythoncode}
N = 1000
T_mrca = np.zeros(N)
for j, ts in enumerate(msprime.simulate(10, num_replicates=N)):
    tree = ts.first()
    T_mrca[j] = tree.time(tree.root)
print(np.mean(T_mrca), np.var(T_mrca))

>>> (3.6690718290544053, 4.8541533617765706)
\end{pythoncode}

    Here we simulate 1000 replicates, storing the time to the most recent
common ancestor for each replicate in the array \texttt{T\_mrca}. (By
default, time is measured in units of \(4 N_e\) generations; see the
next section for details.) We use the Python \texttt{enumerate} function
here to simplify the process of efficiently inserting values into this
array, which simply ensures that \texttt{j} for the first replicate,
\texttt{1} for the second, and so on. Thus, by the time we finish the
loop, the array has been filled with T\_mrca values randomly generated
under the coalescent. We then use the \texttt{numpy} library (which has
an extensive suite of statistical functions) to compute the mean and
variance of this array. This example is idiomatic, and we will use this
type of approach throughout the rest of the tutorial.

It is usually more convenient to use the \texttt{num\_replicates}
argument to peform replication, but there are situations in which it is
better the specify random seeds manually. For example, if simulations
require a long time to run then we may wish to use multiple processes to
run these simulations. To ensure that the seeds used in these different
processes are unique, it is best to manually specify them. For example,

\begin{pythoncode}
def run_simulation(seed):
    ts = msprime.simulate(10, random_seed=seed)
    tree = ts.first()
    return tree.time(tree.root)

N = 1000
seeds = np.random.randint(1, 2**32 - 1, N)
with multiprocessing.Pool(4) as pool:
    T_mrca = np.array(pool.map(run_simulation, seeds))
print(np.mean(T_mrca))

>>> 3.6459775450221832
\end{pythoncode}

    In this example we create a list of 1000 seeds between 1 and $2^{32} -
1$ (the range accepted by msprime) randomly using numpy. We then use the
multiprocessing module to create a worker pool of four processes, and
run our different replicates in these subprocesses. The results are then
collected together in a numpy array so that we can easily process them.
This approach is a straightforward way to fully utilise modern
multi-core processors.

Specifying the same random seed for two different simulations (with the
same parameters) ensures that we get precisely the same results from
both simulations (at least, on the same computer and with the same
software versions). This is very useful when we wish to examine the
properties of a specific simulation (for example, when debugging), or if
we wish to illustrate a particular example. We will often set the random
seed in the examples in this tutorial for this reason.

\subsection{Population models}\label{population-models}

In the previous section the only parameters that we supplied to
\texttt{simulate} were the \texttt{sample\_size} and
\texttt{num\_replicates} parameters. This allows us to randomly sample
trees with a given number of nodes, but has little connection with
biological reality. The most imporant parameter used to model biology in
coalescent simulations is the \emph{effective population size}, or
\texttt{Ne}. This parameter simply rescales time; larger effective
population sizes mean larger coalescence times:

\begin{pythoncode}
def pairwise_T_mrca(Ne):
    N = 10000
    T_mrca = np.zeros(N)
    for j, ts in enumerate(msprime.simulate(2, Ne=Ne, num_replicates=N)):
        tree = ts.first()
        T_mrca[j] = tree.time(tree.root)
    return np.mean(T_mrca)

print(pairwise_T_mrca(0.5), pairwise_T_mrca(10), pairwise_T_mrca(100))

>>> (0.99569690432656333, 19.816809844176138, 196.42125227336615)
\end{pythoncode}

    Thus, when we specify \(N_e=10\) we get a mean coalescence time of about
20 generations, and when \(N_e=100\) the mean coalescence time is about
200 generations. See Wakeley (citation) for details on the biological
interpretation of effective population size.

By default, \(N_e = 1\) in msprime, which is equivalent to measuring
time in units of \(4N_e\) generations. It is very important to note that
\(N_e\) in msprime is the \emph{diploid} effective population size,
which means that all times are scaled by \(4N_e\) (rather than 2Ne for a
haploid coalescent). Thus, if we wish to compare the results that are
given in the literature for a haploid coalescent, then we must set
\(N_e\) to 1/2 to compensate. For example, we know that the expected
coalescence time for a sample of size 2 is 1, and this is the value we
obtain from the \texttt{pairwise\_T\_mrca} function when we have
\(N_e=0.5\). We will usually assume that we are working in haploid
coalescent time units from here on, and so set \(N_e=0.5\) in most
examples. However, when running simulations of a specific organism, it
is substantially more convenient to use an appropriate estimated value
for \(N_e\) so that times are directly interpretable.

\subsubsection{Exponentially growing/shrinking
populations}\label{exponentially-growingshrinking-populations}

When we provide an \(N_e\) parameter, this specifies a fixed effective
population size. We can also model populations that are exponentially
growing or contracting at some rate over time. Given a population size
at the present \(s\) and a growth rate \(\alpha\), the size of the
population \(t\) generations in the past \(s e^{-\alpha t}\). (Note
again that time and rates are measured in units of \emph{generations},
not coalescent units.)

In msprime, the initial size and growth rate for a particular population
are specified using the \texttt{PopulationConfiguration} object. A list
of these objects (describing the different populations; see the
Population Structure section) are then provided to the simulate
function. When providing a list of
\texttt{PopulationConfiguration\ objects}, the \texttt{Ne} parameter to
\texttt{simulate} is not required, as the \texttt{initial\_size} of the
population configurations performs the same task. For example,

\begin{pythoncode}
def pairwise_T_mrca(growth_rate):
    N = 10000
    T_mrca = np.zeros(N)
    replicates = msprime.simulate(
        population_configurations=[
             msprime.PopulationConfiguration(
                sample_size=2, initial_size=0.5, growth_rate=growth_rate)],
        num_replicates=N, random_seed=100)
    for j, ts in enumerate(replicates):
        tree = ts.first()
        T_mrca[j] = tree.time(tree.root)
    return np.mean(T_mrca)

pairwise_T_mrca(0.05), pairwise_T_mrca(0), pairwise_T_mrca(-0.05)

>>> (0.96598072124289924, 1.0124999939843193, 1.0694803236032397)

\end{pythoncode}


    Here we simulate the pairwise \(T_{MRCA}\) for positive, zero and
negative growth rates. When we have a growth rate of zero, we see that
recover the usual result of 1.0 (as our initial size, and hence \(N_e\),
is set to \(1/2\)). When the growth rate is positive, we see that the
mean coalescence time is reduced, since the population size is getting
smaller as we go backwards in time, resulting in an increased rate of
coalescence. Conversely, when we have a negative growth rate, the
population is getting larger as we go backwards in time, resulting in a
slower coalescence rate. (Care must be taken with negative growth rates,
however, as it is possible to specify models in which the MRCA is never
reached. In some cases this will lead to an error being raised, but it
is also possible that the simulator will keep generating events
indefinitely.)

    \subsection{Mutations}\label{mutations}

We cannot directly observe gene genealogies; rather we observe the
effects of mutations occuring on the branches of these trees. We are
there very often interesting not just in the genealogies that are
simulated by the coalescent process, but also in the results of
mutational processes imposed on these trees. Msprime currently supports
simulating mutations under the infinitely many sites model. This is
accessed by the \texttt{mutation\_rate} parameter to the
\texttt{simulate} function. As usual, this rate is the per-generation
rate.

\begin{pythoncode}
ts = msprime.simulate(3, mutation_rate=1, random_seed=7)
tree = ts.first()
SVG(tree.draw())
\end{pythoncode}
\includenbimage{images/simulations_19_0.pdf}

    In this example we have two mutations, shown by the red squares.
Mutations occur above a given node in the tree, and all samples beneath
this node will inherit the mutation. The infinite sites mutations used
here are simple binary mutations, so that the ancestral state is 0 and
the derived state is 1. One convenient way to access the resulting
sample genotypes is to use the \texttt{genotype\_matrix()} method, which
returns an \(m \times n\) numpy array, if we have \(m\) variable sites
and \(n\) samples. Thus, if \(G\) is the genotype matrix, \(G[j, k]\) is
the state of the \(k\)th sample at the \(j\)th site. In our example
above, the site 0 has a mutation over node 3, and site 1 has a mutation
over node 1, and so we get the following matrix:

\begin{pythoncode}
print(ts.genotype_matrix())

>>> array([[1, 0, 1],
           [0, 1, 0]], dtype=uint8)
\end{pythoncode}

    The genotype matrix is provides a convenient way of accessing this
information, but will consume a great deal of memory for larger
simulations. Msprime has an extensive suite of tools for efficiently
working with sequence data and computing population genetics statistics,
and a full review of these tools is beyond the scope of this document.
Please consult the online documentation for more information on
processing simulated sequences.

When comparing with analytical results regarding neutral genetic
variation, it is very imporant to be aware of the way in which the
mutation rates are defined in coalescent theory. For historical reasons,
the scaled mutation rate \(\theta\) is defined as \(2N_e \mu\), where
\(\mu\) is the per-generation mutation rate. Since all times and rates
are specified in units of generations in msprime, we must divide this
factor of two out if we are to compare with analytical predictions. For
example, the mean number of segregating sites for a sample of two is
\(\theta\); to run this in msprime we do the following:

\begin{pythoncode}
N = 10000
theta = 5
S = np.zeros(N)
replicates = msprime.simulate(
    2, Ne=0.5, mutation_rate=theta / 2, num_replicates=N)
for j, ts in enumerate(replicates):
    S[j] = ts.num_sites  # Number of segregrating sites.
print(np.mean(S))

>>> 4.8276000000000003
\end{pythoncode}

    Note that here we set the mutation rate to \(\theta / 2\) (to cancel out
the factor of 2 in the definition of \(\theta\)) and \(N_e = 1/2\) (so
that time is measured in haploid coalescent time units). Such
factor-of-two gymnastics are unfortunately unavoidable in coalescent
theory.

\subsection{Population structure}\label{population-structure}

Msprime supports a discrete-deme model of population structure in which
\(d\) panmictic populations exchange migrants according to the rates
defined in an \(d \times d\) matrix. This approach is very flexible,
allowing us to simulate island models (in which all populations exchange
migrants at a fixed rate), one and two dimensional stepping stone models
(where migrants only move to adjacent demes) and other more complex
migration patterns.

This population structure is declared in msprime using the
\texttt{population\_configurations} and \texttt{migration\_matrix}
parameters to the \texttt{simulate} function. The list of population
configurations defines the populations; each element of this list must
be a \texttt{PopulationConfiguration} instance (each population has
independent initial population size and growth rate parameters). The
migration matrix is a numpy array (or list of lists) of per-generation
migration rates; \(M[j,k]\) defines the fraction of population \(j\)
that consists of migrants from population \(k\) in each generation.

\begin{pythoncode}
pop_configs = [
    msprime.PopulationConfiguration(sample_size=2),
    msprime.PopulationConfiguration(sample_size=2)
]
M = np.array([
    [0, 0.1],
    [0, 0]
])
ts  = msprime.simulate(
    population_configurations=pop_configs, migration_matrix=M,
    random_seed=2)
tree = ts.first()
colour_map = {0:"red", 1:"blue"}
node_colours = {
    u: colour_map[tree.population(u)] for u in tree.nodes()}
SVG(tree.draw(node_colours=node_colours))
\end{pythoncode}

\includenbimage{images/simulations_26_0.pdf}

    We create our population model by first making a list of two
\texttt{PopulationConfiguration} objects. For convenience here, we use
the \texttt{sample\_size} argument to these objects to state that we
wish to have two samples from each population. This results in samples
being allocated sequentially to the populations when \texttt{simulate}
is called: 0 and 1 are placed in population 0, and samples 2 and 3 are
place in population 1. We then declare our migration matrix, which is
asymmetric in this example. Because \texttt{M{[}0,1{]}\ =\ 0.1} and
\texttt{M{[}0,1{]}\ =\ 0}, forwards in time, individuals can migrate
from population 1 to population 0 but not vice-versa. This is shown in
the tree for this simulation, where each node has been coloured by its
population (red is population 0 and blue population 1). Thus, the leaf
nodes 0 and 1 are both from population 0, and 2 and 3 are both from
population 2 (as explained above). As we go up the tree, the first event
that occurs is 2 and 3 coalescing in population 1, creating node 4.
After this, 4 coalesces with with node 0, which has at some point before
this migrated into deme 1, creating node 5. Node 1 also migrates into
deme 1, where it coalesces with 5. Because migration is asymmetric here,
the most recent common ancestor of the four samples \emph{must} occur
within deme 1.

The exact history of migration events is available if we use the
\texttt{record\_migrations} option. In the next example, we set up a
symmetric island model and track every migration event:

\begin{pythoncode}
pop_configs = [
    msprime.PopulationConfiguration(sample_size=3),
    msprime.PopulationConfiguration(sample_size=1),
    msprime.PopulationConfiguration(sample_size=1)]
M = [
    [0, 1, 1],
    [1, 0, 1],
    [1, 1, 0]]
ts  = msprime.simulate(
    population_configurations=pop_configs, migration_matrix=M,
    record_migrations=True, random_seed=101)
tree = ts.first()
colour_map = {0:"red", 1:"blue", 2: "green"}
node_colours = {
    u: colour_map[tree.population(u)] for u in tree.nodes()}
SVG(tree.draw(node_colours=node_colours))
\end{pythoncode}
\includenbimage{images/simulations_28_0.pdf}

    Here we sample three nodes from population 0, but because we have a lot
of migration the locations of coalescences are quite random. For
example, the first coalescence occurs in deme 2 (green), after node zero
has migrated in. To see the details of these migration events, we can
examine the "migration records" that are stored by msprime. (These are
not stored by default, as they may require a substantial amount of
memory to store. The \texttt{record\_migrations} parameter must be
supplied to \texttt{simulate} to turn on this feature.) Migration
records store complete information about the time, source and
destination demes and the genomic interval in question. Here we are
interested in the total number of migrations experienced by each node:

\begin{pythoncode}
node_count = np.zeros(ts.num_nodes)
for migration in ts.migrations():
    node_count[migration.node] += 1
plt.bar(np.arange(ts.num_nodes), node_count)
plt.xlabel("Node ID")
plt.ylabel("Number of migrations");
\end{pythoncode}
\includenbimage{images/simulations_30_0.pdf}

We can see that node zero experienced very few migrations before it
ended up in deme 2, where it coalesced with 4 (which never migrated).
Node 2, on the other hand migrated 30 times before it finally coalesced
with 7 in deme 0. Note that there are many more migrations events than
nodes there, implying that most migration events are not identifiable
from a genealogy in real data (CITE:
http://onlinelibrary.wiley.com/doi/10.1111/j.1365-294X.2011.05247.x/abstract).

Other forms of migration are also possible between specific demes at
specific times. These are one of a number of different demographic
event, which are dealt with in the next section.

\subsection{Demographic events}\label{demographic-events}

Demographic events allow us to model more complex histories involving
changes to the population structure over time. These are specified using
the \texttt{demographic\_events} parameter to \texttt{simulate}. Each
demographic event occurs at a specific time, and the list of events must
be supplied in the order they occur (backwards in time). There are a
number of different types of demographic event, which we examine in
turn.

\subsubsection{Migration rate change}\label{migration-rate-change}

Migration rate change events allow us to update the migration rate
matrix at some point in time. We can either update a single cell in the
matrix or all (non-diagonal) entries at the same time.
\begin{pythoncode}
ts  = msprime.simulate(
    population_configurations=[
        msprime.PopulationConfiguration(sample_size=2),
        msprime.PopulationConfiguration(sample_size=2)],
    demographic_events=[
        msprime.MigrationRateChange(20, rate=1.0, matrix_index=(0, 1))],
    random_seed=2)
tree = ts.first()
colour_map = {0:"red", 1:"blue"}
node_colours = {u: colour_map[tree.population(u)] for u in tree.nodes()}
node_labels = {
    u: (str(u) if tree.is_sample(u) else "{} (t={:.1f})".format(u,
tree.time(u)))
    for u in tree.nodes()}
SVG(tree.draw(node_colours=node_colours, node_labels=node_labels))
\end{pythoncode}

\includenbimage{images/simulations_34_0.pdf}

    As before, the sample 0 and 1, and 2 and 3 coalesce quickly within their
own populations. However, because the migration rate between the
populations is zero these lineages are isolated and would never coalesce
without some change in demography. The migration rate change event
happens at time 20, resulting in node 5 migrating to deme 1 soon
afterwards. The lineages then coalesce at time 21.44.

\subsubsection{Mass migration}\label{mass-migration}

This class of event allows us to move some proportion of the lineages in
one deme to another at a particular time. This allows us to model
population splits and admixture events.

Population splits occur when some fraction of the lineages from a
population migrate to another population.

\begin{pythoncode}
ts  = msprime.simulate(
    population_configurations=[
        msprime.PopulationConfiguration(sample_size=3),
        msprime.PopulationConfiguration(sample_size=3)],
    demographic_events=[
        msprime.MassMigration(15, source=1, dest=0, proportion=1)],
    random_seed=20)
tree = ts.first()
colour_map = {0:"red", 1:"blue"}
node_colours = {u: colour_map[tree.population(u)] for u in tree.nodes()}
node_labels = {
    u: (str(u) if u < 8 else "{} (t={:.2f})".format(u, tree.time(u)))
    for u in tree.nodes()}
SVG(tree.draw(node_colours=node_colours, node_labels=node_labels))
\end{pythoncode}

\includenbimage{images/simulations_37_0.pdf}

Again, we have two isolated populations which coalesce down to a single
lineage. The population split at time 15 (which produced all individuals
in population 1), then results in this lineage migrating back to
population 0, where it coalesces with the ancestor of the samples 0, 1
and 2.

Admixture events (i.e., where some fraction of the lineages move to a
different deme) are specified in the same way:

\begin{pythoncode}
ts  = msprime.simulate(
    population_configurations=[
        msprime.PopulationConfiguration(sample_size=6),
        msprime.PopulationConfiguration(sample_size=0)],
    demographic_events=[
        msprime.MassMigration(0.5, source=0, dest=1, proportion=0.5),
        msprime.MigrationRateChange(1.1, rate=0.1),
    ],
    random_seed=26)
tree = ts.first()
colour_map = {0:"red", 1:"blue"}
node_colours = {u: colour_map[tree.population(u)] for u in tree.nodes()}
node_labels = {
    u: (str(u) if u < 8 else "{} (t={:.1f})".format(u, tree.time(u)))
    for u in tree.nodes()}
SVG(tree.draw(node_colours=node_colours, node_labels=node_labels))
\end{pythoncode}

\includenbimage{images/simulations_39_0.pdf}

    We begin in this example with 6 lineages sampled in population 0, zero
samples in population 1, and with no migration between these
populations. Then, at time 0.5, we have an admixture event where each of
the 4 extant lineages (5, 7, 0 and 6) has a probability of 1/2 of moving
to deme 1. Linages 0 and 6 migrate, and subsequently coalesce into node
8. Further back in time, at \(t=1.1\), another demographic event occurs,
changing the migration rate between the demes to 0.1, thereby allowing
lineages to move between them. Eventually, all lineages end up in deme
1, where they coalesce into the MRCA at time \(t=6.9\).

\subsubsection{Population parameter change}\label{population-parameter-change}

This class of event represents a simple change in the growth rate or
size of a particular population. Since each population has it's own
individual size and growth rates, we can change these arbitrarily as we
go backwards in time. Keeping track of the actual sizes of different
populations can be a little challenging, and for this reason msprime
provides a \texttt{DemographyDebugger} class.

To illustrate this we consider a very simple example in which we have a
single population experiencing an phase of exponential growth from 750
to 100 generations ago. The size of the population 750 generations ago
was 2000, and it grew to 20,000 over the next 650 generations. The size
of the population has been stable at this value for the past 100
generations. We can encode this model as follows:

\begin{pythoncode}
N1 = 20000  # Population size at present
N2 = 2000   # Population size at start (forwards in time) of exponential growth.
T1 = 100    # End of exponential growth period (forwards in time)
T2 = 750    # Start of exponential growth period (forwards in time)
# Calculate growth rate; solve N2 = N1 * exp(-alpha * (T2 - T1))
growth_rate = -np.log(N2 / N1) / (T2 - T1)
population_configurations = [
    msprime.PopulationConfiguration(initial_size=N1)
]
demographic_events = [
    msprime.PopulationParametersChange(time=T1, growth_rate=growth_rate),
    msprime.PopulationParametersChange(time=T2, growth_rate=0),
]
dp = msprime.DemographyDebugger(
    population_configurations=population_configurations,
    demographic_events=demographic_events)
dp.print_history()
\end{pythoncode}

Gives the following output:
\begin{footnotesize}
\begin{verbatim}
=============================
Epoch: 0 -- 100.0 generations
=============================
     start     end      growth_rate |     0
   -------- --------       -------- | --------
0 |  2e+04    2e+04               0 |     0

Events @ generation 100.0
   - Population parameter change for -1: growth_rate -> 0.0035

=================================
Epoch: 100.0 -- 750.0 generations
=================================
     start     end      growth_rate |     0
   -------- --------       -------- | --------
0 |  2e+04    2e+03         0.00354 |     0

Events @ generation 750.0
   - Population parameter change for -1: growth_rate -> 0

===============================
Epoch: 750.0 -- inf generations
===============================
     start     end      growth_rate |     0
   -------- --------       -------- | --------
0 |  2e+03    2e+03               0 |     0

\end{verbatim}
\end{footnotesize}

    After we set up our model, we use the \texttt{DemographyDebugger} to
check our calculations. We see that time has been split into three
``epochs''. From the present until 100 generations ago, we see that the
population size is constant at 20,000. Then, we have a demographic event
that changes the growth rate to 0.0035, which applies over the next
epoch (from 100 to 750 generations ago). Over this time, the population
grows from 2000 to 20,000, as we specified (note that the "start" and
"end" of each epoch is looking \emph{backwards} in time, as we consider
epochs starting from the present and moving backwards). At generation
750 another event occurs, setting the growth rate for the population to
0. Then, the population size is constant at 20,000 from generation 750
until the indefinite past.

A more complex example involving a three population out-of-Africa human
model is available in the online documentation.

\subsection{Ancient samples}\label{ancient-samples}

Up to this point we have assumed that all samples are taken at the
present time. However, msprime allows us to specify abitrary sampling
times and locations, allowing us to simulate (for example) ancient
samples.

\begin{pythoncode}
ts = msprime.simulate(
    samples=[
        msprime.Sample(0, 0), msprime.Sample(0, 0), msprime.Sample(0, 0),
        msprime.Sample(1, 0.75), # Ancient sample in deme 1
    ],
    population_configurations=[
        msprime.PopulationConfiguration(),
        msprime.PopulationConfiguration()],
    migration_matrix=[
        [0, 1],
        [1, 0]],
    random_seed=22)
tree = ts.first()
colour_map = {0:"red", 1:"blue"}
node_colours = {u: colour_map[tree.population(u)] for u in tree.nodes()}
node_labels = {
    u: (str(u) if u != 3 else "{} (t={:.2f})".format(u, tree.time(u)))
    for u in tree.nodes()}
SVG(tree.draw(node_colours=node_colours, node_labels=node_labels))
\end{pythoncode}

\includenbimage{images/simulations_45_0.pdf}

All of the trees that we previously considered had leaf nodes at time
zero. In this case, the sampes 0, 1 and 2 are taken at time 0 in
population 0, but node 3 is sampled at time 0.75 in population 1. Note
that in this case we used the \texttt{samples} parameter to
\texttt{simulate} to specify our samples. This is the most general
approach to assigning samples, and allows for samples to be assigned to
arbitrary populations and at arbitrary times.

\subsection{Recombination}\label{recombination}

One of the key innovations of msprime is that it makes simulation of the
full coalescent with recombination possible at a whole chromosome scale.
Adding recombination to a simulation is simple, requiring very minor
changes to the methods given above.

\begin{pythoncode}
ts = msprime.simulate(
    10, Ne=1e4, length=1e5, recombination_rate=1e-8, random_seed=3)
ts.num_trees

>>> 82
\end{pythoncode}

    In this case, we provide two extra parameters: \texttt{length}, which
defines the lengths of the genomic region to be simulated, and
\texttt{recombination\_rate}, which defines the rate of recombination
per unit of sequence length, per generation. It is usually useful tp
think of the length and recombination rate being defined in terms
base-pairs (but note that these are continuous values, so this
correspondence should not be taken too literally). For this example, we
defined a sequence length of 10kb, and a recombination rate of
\(10^{-8}\) per base per generation. The result of this simulation is a
\emph{tree sequence} that contains 82 distinct trees.

Up to this point we have assumed that our simulations returned a single
tree representing the genealogy of our sample. The inclusion of
recombination, however, means that there may be more than one tree
relating our samples. The \texttt{TreeSequence} object returned by
msprime is a very concise and efficient representation of these highly
correlated trees. To process these trees, we simply need to consider
them one at a time, using the \texttt{trees()} iterator.

\begin{pythoncode}
tmrca = np.zeros(ts.num_trees)
breakpoints = np.zeros(ts.num_trees)
for tree in ts.trees():
    tmrca[tree.index] = tree.time(tree.root)
    breakpoints[tree.index] = tree.interval[0]
plt.ylabel("T_mrca (Generations)")
plt.xlabel("Position (kb)")
plt.plot(breakpoints / 1000, tmrca, "o");
\end{pythoncode}

\includenbimage{images/simulations_50_0.pdf}

    Here we plot the time of the MRCA of the sample for each tree across the
sequence. We find the \(T_{MRCA}\) as before, and plot this by the
position of the left-most position of this tree. A full description of
tree sequence and the methods for working with them is beyond the scope
of this document; please see the online documentation for more details.

It is also possible to simulate data with recombination rates varying
across the genome (e.g., in recombination hotspots). To do this, we
first create a \texttt{RecombinationMap} instance that describes the
properties of the recombination landscape that you with to simulate. We
then supply this value to \texttt{simulate} using the
\texttt{recombination\_map} argument. In the following example, we
simulate 100 samples using the human chromosome 22 recombination map
from the HapMap project:


\begin{pythoncode}
# Read in the recombination map and run the simulation.
infile = "genetic_map_GRCh37_chr22.txt"
recomb_map = msprime.RecombinationMap.read_hapmap(infile)
ts = msprime.simulate(
    sample_size=100,
    Ne=10**4,
    recombination_map=recomb_map,
    random_seed=1)
\end{pythoncode}


\includenbimage{images/simulations_53_0.pdf}

    This plot shows the recombination rate and the locations of breakpoints
from the simulation, and the density of breakpoints closely follows the
recombination rate, as expected.

Although coordinates are specified in floating point values, msprime
uses a discrete loci model when performing simulations. By default, the
number of loci is very large (\(~\sim 2^{32}\)), and the locations of
breakpoints are translated back into the coordinate system defined by
the recombination map. However, the number of loci is configurable and
can be specified if you wish to simulate a specific number of discrete
loci.

\begin{pythoncode}
recomb_map = msprime.RecombinationMap.uniform_map(length=10, rate=1,
num_loci=10)
ts = msprime.simulate(2, recombination_map=recomb_map)
print(list(ts.breakpoints()))

>>> [0, 1.0, 2.0, 3.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
\end{pythoncode}


    Here we simulate a pairwise sample for a system with 10 loci, each of
length 1 with recombination rate of 1 between adjacent loci per
generation. In the output, we see that the breakpoints between trees now
occur exactly at the integer boundaries bewtween these loci.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Analysing simulation results}
\label{sec:analysing}
In the previous section we saw how to run simulations of various biological models
using \msprime. A major advantage of \msprime\ over simulators that are structured
as a command line program is that we can analyse our data in the same script
as we generated it. This facilitates reproduciblility as well as being much
more efficient (parsing the text output by simulators is inefficient). In this
section we show some examples of how to use the \msprime\ API to analyse the
data produced by simulations.

\subsection{Tree Sequences}
\label{sec:tree-sequences}
In this subsection we describe the basic data structure that underlies all of
\msprime's APIs.

\subsection{Tree traversals}
\label{sec:tree-traversals}


\subsection{Genotype data}
\label{sec:sequence-data}
For many tasks we wish to have direct access to the observed sequence
data, i.e., the sample genotypes. The most efficient way to access this
information in \msprime\ is to use the \apiref{variants} iterator.

[Example of using the variants iterator]

The \msprime\ API is not currently a complete solution for calculating
statistics of interest in population genetics [mention ongoing work
with Peter Ralph here?]. However, there are two excellent Python
libraries for efficiently working with sequence data that can efficiently
accept data from \msprime. We briefly illustrate their usage here.

The \texttt{scikit-allel}\citep{miles2017scikit} package provides a
comprehensive suite of utilities for working with data.
[Short example using scikit-allel]

Another option is to use the \texttt{pylibseq} package, which is a
Python interface to the powerful \texttt{libsequence}
library~\citep{thornton2003libsequence}. [Short example using pylibseq]


\section{Data examples}
\label{sec:data-examples}

In this section we apply the tools developed in sections~\ref{sec:simulations}
and~\ref{sec:analysing} to some real data examples.


\bibliography{references}


\clearpage
\appendix
\section{Stuff from template}
\label{sec:1}
Use the template \emph{chapter.tex} together with the Springer document class SVMono (monograph-type books) or SVMult (edited books) to style the various elements of your chapter content in the Springer layout.

Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations. And please note that the first line of
text that follows a heading is not indented, whereas the first lines of
all subsequent paragraphs are.

\section{Section Heading}
\label{sec:2}
% Always give a unique label
% and use \ref{<label>} for cross-references
% and \cite{<label>} for bibliographic references
% use \sectionmark{}
% to alter or adjust the section heading in the running head
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations.

Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.

Use the standard \verb|equation| environment to typeset your equations, e.g.
%
\begin{equation}
a \times b = c\;,
\end{equation}
%
however, for multiline equations we recommend to use the \verb|eqnarray| environment\footnote{In physics texts please activate the class option \texttt{vecphys} to depict your vectors in \textbf{\itshape boldface-italic} type - as is customary for a wide range of physical subjects}.
\begin{eqnarray}
a \times b = c \nonumber\\
\vec{a} \cdot \vec{b}=\vec{c}
\label{eq:01}
\end{eqnarray}

\subsection{Subsection Heading}
\label{subsec:2}
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references\index{cross-references} and citations\index{citations}
as has already been described in Sect.~\ref{sec:2}.

\begin{quotation}
Please do not use quotation marks when quoting texts! Simply use the \verb|quotation| environment -- it will automatically render Springer's preferred layout.
\end{quotation}


\subsubsection{Subsubsection Heading}
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations as has already been described in
Sect.~\ref{subsec:2}, see also Fig.~\ref{fig:1}\footnote{If you copy
text passages, figures, or tables from other works, you must obtain
\textit{permission} from the copyright holder (usually the original
publisher). Please enclose the signed permission with the manucript. The
sources\index{permission to print} must be acknowledged either in the
captions, as footnotes or in a separate section of the book.}

Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.

% For figures use
%
\begin{figure}[b]
\sidecaption
% Use the relevant command for your figure-insertion program
% to insert the figure file.
% For example, with the graphicx style use
\includegraphics[scale=.65]{figure}
%
% If no graphics program available, insert a blank space i.e. use
%\picplace{5cm}{2cm} % Give the correct figure height and width in cm
%
\caption{If the width of the figure is less than 7.8 cm use the \texttt{sidecapion} command to flush the caption on the left side of the page. If the figure is positioned at the top of the page, align the sidecaption with the top of the figure -- to achieve this you simply need to use the optional argument \texttt{[t]} with the \texttt{sidecaption} command}
\label{fig:1}       % Give a unique label
\end{figure}


\paragraph{Paragraph Heading} %
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations as has already been described in
Sect.~\ref{sec:2}.

Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.

For typesetting numbered lists we recommend to use the \verb|enumerate| environment -- it will automatically render Springer's preferred layout.

\begin{enumerate}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\begin{enumerate}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\end{enumerate}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\end{enumerate}


\subparagraph{Subparagraph Heading} In order to avoid simply listing headings of different levels we recommend to let every heading be followed by at least a short passage of text. Use the \LaTeX\ automatism for all your cross-references and citations as has already been described in Sect.~\ref{sec:2}, see also Fig.~\ref{fig:2}.

For unnumbered list we recommend to use the \verb|itemize| environment -- it will automatically render Springer's preferred layout.

\begin{itemize}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development, cf. Table~\ref{tab:1}.}
\begin{itemize}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\end{itemize}
\item{Livelihood and survival mobility are oftentimes coutcomes of uneven socioeconomic development.}
\end{itemize}

\begin{figure}[t]
\sidecaption[t]
% Use the relevant command for your figure-insertion program
% to insert the figure file.
% For example, with the option graphics use
\includegraphics[scale=.65]{figure}
%
% If no graphics program available, insert a blank space i.e. use
%\picplace{5cm}{2cm} % Give the correct figure height and width in cm
%
%\caption{Please write your figure caption here}
\caption{If the width of the figure is less than 7.8 cm use the \texttt{sidecapion} command to flush the caption on the left side of the page. If the figure is positioned at the top of the page, align the sidecaption with the top of the figure -- to achieve this you simply need to use the optional argument \texttt{[t]} with the \texttt{sidecaption} command}
\label{fig:2}       % Give a unique label
\end{figure}

\runinhead{Run-in Heading Boldface Version} Use the \LaTeX\ automatism for all your cross-references and citations as has already been described in Sect.~\ref{sec:2}.

\subruninhead{Run-in Heading Italic Version} Use the \LaTeX\ automatism for all your cross-refer\-ences and citations as has already been described in Sect.~\ref{sec:2}\index{paragraph}.
% Use the \index{} command to code your index words
%
% For tables use
%
\begin{table}
\caption{Please write your table caption here}
\label{tab:1}       % Give a unique label
%
% Follow this input for your own table layout
%
\begin{tabular}{p{2cm}p{2.4cm}p{2cm}p{4.9cm}}
\hline\noalign{\smallskip}
Classes & Subclass & Length & Action Mechanism  \\
\noalign{\smallskip}\svhline\noalign{\smallskip}
Translation & mRNA$^a$  & 22 (19--25) & Translation repression, mRNA cleavage\\
Translation & mRNA cleavage & 21 & mRNA cleavage\\
Translation & mRNA  & 21--22 & mRNA cleavage\\
Translation & mRNA  & 24--26 & Histone and DNA Modification\\
\noalign{\smallskip}\hline\noalign{\smallskip}
\end{tabular}
$^a$ Table foot note (with superscript)
\end{table}
%
\section{Section Heading}
\label{sec:3}
% Always give a unique label
% and use \ref{<label>} for cross-references
% and \cite{<label>} for bibliographic references
% use \sectionmark{}
% to alter or adjust the section heading in the running head
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations as has already been described in
Sect.~\ref{sec:2}.

Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.

If you want to list definitions or the like we recommend to use the Springer-enhanced \verb|description| environment -- it will automatically render Springer's preferred layout.

\begin{description}[Type 1]
\item[Type 1]{That addresses central themes pertainng to migration, health, and disease. In Sect.~\ref{sec:1}, Wilson discusses the role of human migration in infectious disease distributions and patterns.}
\item[Type 2]{That addresses central themes pertainng to migration, health, and disease. In Sect.~\ref{subsec:2}, Wilson discusses the role of human migration in infectious disease distributions and patterns.}
\end{description}

\subsection{Subsection Heading} %
In order to avoid simply listing headings of different levels we recommend to let every heading be followed by at least a short passage of text. Use the \LaTeX\ automatism for all your cross-references and citations citations as has already been described in Sect.~\ref{sec:2}.

Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.

\begin{svgraybox}
If you want to emphasize complete paragraphs of texts we recommend to use the newly defined Springer class option \verb|graybox| and the newly defined environment \verb|svgraybox|. This will produce a 15 percent screened box 'behind' your text.

If you want to emphasize complete paragraphs of texts we recommend to use the newly defined Springer class option and environment \verb|svgraybox|. This will produce a 15 percent screened box 'behind' your text.
\end{svgraybox}


\subsubsection{Subsubsection Heading}
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations as has already been described in
Sect.~\ref{sec:2}.

Please note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.

\begin{theorem}
Theorem text goes here.
\end{theorem}
%
% or
%
\begin{definition}
Definition text goes here.
\end{definition}

\begin{proof}
%\smartqed
Proof text goes here.
\qed
\end{proof}

\paragraph{Paragraph Heading} %
Instead of simply listing headings of different levels we recommend to
let every heading be followed by at least a short passage of text.
Further on please use the \LaTeX\ automatism for all your
cross-references and citations as has already been described in
Sect.~\ref{sec:2}.

Note that the first line of text that follows a heading is not indented, whereas the first lines of all subsequent paragraphs are.
%
% For built-in environments use
%
\begin{theorem}
Theorem text goes here.
\end{theorem}
%
\begin{definition}
Definition text goes here.
\end{definition}
%
\begin{proof}
\smartqed
Proof text goes here.
\qed
\end{proof}
%
\begin{acknowledgement}
If you want to include acknowledgments of assistance and the like at the end of an individual chapter please use the \verb|acknowledgement| environment -- it will automatically render Springer's preferred layout.
\end{acknowledgement}
%
\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}
%
%
When placed at the end of a chapter or contribution (as opposed to at the end of the book), the numbering of tables, figures, and equations in the appendix section continues on from that in the main text. Hence please \textit{do not} use the \verb|appendix| command when writing an appendix at the end of your chapter or contribution. If there is only one the appendix is designated ``Appendix'', or ``Appendix 1'', or ``Appendix 2'', etc. if there is more than one.

\begin{equation}
a \times b = c
\end{equation}

\end{document}
